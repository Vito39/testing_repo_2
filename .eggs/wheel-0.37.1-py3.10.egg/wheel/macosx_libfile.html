<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>}; &mdash; Polly_Documentation 1 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> Polly_Documentation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Polly.html">About Polly Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../polly.html">polly package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../download.html">Downloading Dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../query.html">Querying metadata</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Polly_Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>};</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/.eggs/wheel-0.37.1-py3.10.egg/wheel/macosx_libfile.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””
This module contains function to analyse dynamic library
headers to extract system information</p>
<p>Currently only for MacOSX</p>
<p>Library file on macosx system starts with Mach-O or Fat field.
This can be distinguish by first 32 bites and it is called magic number.
Proper value of magic number is with suffix _MAGIC. Suffix _CIGAM means
reversed bytes order.
Both fields can occur in two types: 32 and 64 bytes.</p>
<p>FAT field inform that this library contains few version of library
(typically for different types version). It contains
information where Mach-O headers starts.</p>
<p>Each section started with Mach-O header contains one library
(So if file starts with this field it contains only one version).</p>
<p>After filed Mach-O there are section fields.
Each of them starts with two fields:
cmd - magic number for this command
cmdsize - total size occupied by this section information.</p>
<p>In this case only sections LC_VERSION_MIN_MACOSX (for macosx 10.13 and earlier)
and LC_BUILD_VERSION (for macosx 10.14 and newer) are interesting,
because them contains information about minimal system version.</p>
<p>Important remarks:
- For fat files this implementation looks for maximum number version.</p>
<blockquote>
<div><p>It not check if it is 32 or 64 and do not compare it with currently built package.
So it is possible to false report higher version that needed.</p>
</div></blockquote>
<ul class="simple">
<li><p>All structures signatures are taken form macosx header files.</p></li>
<li><p>I think that binary format will be more stable than <cite>otool</cite> output.
and if apple introduce some changes both implementation will need to be updated.</p></li>
<li><p>The system compile will set the deployment target no lower than
11.0 for arm64 builds. For “Universal 2” builds use the x86_64 deployment
target when the arm64 target is 11.0.</p></li>
</ul>
<p>“””</p>
<p>import ctypes
import os
import sys</p>
<p>“””here the needed const and struct from mach-o header files”””</p>
<p>FAT_MAGIC = 0xcafebabe
FAT_CIGAM = 0xbebafeca
FAT_MAGIC_64 = 0xcafebabf
FAT_CIGAM_64 = 0xbfbafeca
MH_MAGIC = 0xfeedface
MH_CIGAM = 0xcefaedfe
MH_MAGIC_64 = 0xfeedfacf
MH_CIGAM_64 = 0xcffaedfe</p>
<p>LC_VERSION_MIN_MACOSX = 0x24
LC_BUILD_VERSION = 0x32</p>
<p>CPU_TYPE_ARM64 = 0x0100000c</p>
<dl>
<dt>mach_header_fields = [</dt><dd><blockquote>
<div><p>(“magic”, ctypes.c_uint32), (“cputype”, ctypes.c_int),
(“cpusubtype”, ctypes.c_int), (“filetype”, ctypes.c_uint32),
(“ncmds”, ctypes.c_uint32), (“sizeofcmds”, ctypes.c_uint32),
(“flags”, ctypes.c_uint32)</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>“””
struct mach_header {</p>
<blockquote>
<div><p>uint32_t    magic;          /* mach magic number identifier <em>/
cpu_type_t  cputype;        /</em> cpu specifier <em>/
cpu_subtype_t       cpusubtype;     /</em> machine specifier <em>/
uint32_t    filetype;       /</em> type of file <em>/
uint32_t    ncmds;          /</em> number of load commands <em>/
uint32_t    sizeofcmds;     /</em> the size of all the load commands <em>/
uint32_t    flags;          /</em> flags <a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</div></blockquote>
<p>};
typedef integer_t cpu_type_t;
typedef integer_t cpu_subtype_t;
“””</p>
<p>mach_header_fields_64 = mach_header_fields + [(“reserved”, ctypes.c_uint32)]
“””
struct mach_header_64 {</p>
<blockquote>
<div><p>uint32_t    magic;          /* mach magic number identifier <em>/
cpu_type_t  cputype;        /</em> cpu specifier <em>/
cpu_subtype_t       cpusubtype;     /</em> machine specifier <em>/
uint32_t    filetype;       /</em> type of file <em>/
uint32_t    ncmds;          /</em> number of load commands <em>/
uint32_t    sizeofcmds;     /</em> the size of all the load commands <em>/
uint32_t    flags;          /</em> flags <em>/
uint32_t    reserved;       /</em> reserved <a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</div></blockquote>
<section id="id5">
<h1>};<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h1>
<p>fat_header_fields = [(“magic”, ctypes.c_uint32), (“nfat_arch”, ctypes.c_uint32)]
“””
struct fat_header {</p>
<blockquote>
<div><p>uint32_t    magic;          /* FAT_MAGIC or FAT_MAGIC_64 <em>/
uint32_t    nfat_arch;      /</em> number of structs that follow <a href="#id6"><span class="problematic" id="id7">*</span></a>/</p>
</div></blockquote>
</section>
<section id="id8">
<h1>};<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h1>
<dl class="simple">
<dt>fat_arch_fields = [</dt><dd><p>(“cputype”, ctypes.c_int), (“cpusubtype”, ctypes.c_int),
(“offset”, ctypes.c_uint32), (“size”, ctypes.c_uint32),
(“align”, ctypes.c_uint32)</p>
</dd>
</dl>
</section>
<section id="id9">
<h1>]<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h1>
<dl class="simple">
<dt>struct fat_arch {</dt><dd><p>cpu_type_t  cputype;        /* cpu specifier (int) <em>/
cpu_subtype_t       cpusubtype;     /</em> machine specifier (int) <em>/
uint32_t    offset;         /</em> file offset to this object file <em>/
uint32_t    size;           /</em> size of this object file <em>/
uint32_t    align;          /</em> alignment as a power of 2 <a href="#id10"><span class="problematic" id="id11">*</span></a>/</p>
</dd>
</dl>
</section>
<section id="id12">
<h1>};<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h1>
<dl class="simple">
<dt>fat_arch_64_fields = [</dt><dd><p>(“cputype”, ctypes.c_int), (“cpusubtype”, ctypes.c_int),
(“offset”, ctypes.c_uint64), (“size”, ctypes.c_uint64),
(“align”, ctypes.c_uint32), (“reserved”, ctypes.c_uint32)</p>
</dd>
</dl>
</section>
<section id="id13">
<h1>]<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h1>
<dl class="simple">
<dt>struct fat_arch_64 {</dt><dd><p>cpu_type_t  cputype;        /* cpu specifier (int) <em>/
cpu_subtype_t       cpusubtype;     /</em> machine specifier (int) <em>/
uint64_t    offset;         /</em> file offset to this object file <em>/
uint64_t    size;           /</em> size of this object file <em>/
uint32_t    align;          /</em> alignment as a power of 2 <em>/
uint32_t    reserved;       /</em> reserved <a href="#id14"><span class="problematic" id="id15">*</span></a>/</p>
</dd>
</dl>
</section>
<section id="id16">
<h1>};<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h1>
<p>segment_base_fields = [(“cmd”, ctypes.c_uint32), (“cmdsize”, ctypes.c_uint32)]
“””base for reading segment info”””</p>
<dl class="simple">
<dt>segment_command_fields = [</dt><dd><p>(“cmd”, ctypes.c_uint32), (“cmdsize”, ctypes.c_uint32),
(“segname”, ctypes.c_char * 16), (“vmaddr”, ctypes.c_uint32),
(“vmsize”, ctypes.c_uint32), (“fileoff”, ctypes.c_uint32),
(“filesize”, ctypes.c_uint32), (“maxprot”, ctypes.c_int),
(“initprot”, ctypes.c_int), (“nsects”, ctypes.c_uint32),
(“flags”, ctypes.c_uint32),
]</p>
</dd>
</dl>
<p>“””
struct segment_command { /* for 32-bit architectures <a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
<blockquote>
<div><p>uint32_t    cmd;            /* LC_SEGMENT <em>/
uint32_t    cmdsize;        /</em> includes sizeof section structs <em>/
char                segname[16];    /</em> segment name <em>/
uint32_t    vmaddr;         /</em> memory address of this segment <em>/
uint32_t    vmsize;         /</em> memory size of this segment <em>/
uint32_t    fileoff;        /</em> file offset of this segment <em>/
uint32_t    filesize;       /</em> amount to map from the file <em>/
vm_prot_t   maxprot;        /</em> maximum VM protection <em>/
vm_prot_t   initprot;       /</em> initial VM protection <em>/
uint32_t    nsects;         /</em> number of sections in segment <em>/
uint32_t    flags;          /</em> flags <a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</div></blockquote>
<p>};
typedef int vm_prot_t;
“””</p>
<dl class="simple">
<dt>segment_command_fields_64 = [</dt><dd><p>(“cmd”, ctypes.c_uint32), (“cmdsize”, ctypes.c_uint32),
(“segname”, ctypes.c_char * 16), (“vmaddr”, ctypes.c_uint64),
(“vmsize”, ctypes.c_uint64), (“fileoff”, ctypes.c_uint64),
(“filesize”, ctypes.c_uint64), (“maxprot”, ctypes.c_int),
(“initprot”, ctypes.c_int), (“nsects”, ctypes.c_uint32),
(“flags”, ctypes.c_uint32),
]</p>
</dd>
</dl>
<p>“””
struct segment_command_64 { /* for 64-bit architectures <a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
<blockquote>
<div><p>uint32_t    cmd;            /* LC_SEGMENT_64 <em>/
uint32_t    cmdsize;        /</em> includes sizeof section_64 structs <em>/
char                segname[16];    /</em> segment name <em>/
uint64_t    vmaddr;         /</em> memory address of this segment <em>/
uint64_t    vmsize;         /</em> memory size of this segment <em>/
uint64_t    fileoff;        /</em> file offset of this segment <em>/
uint64_t    filesize;       /</em> amount to map from the file <em>/
vm_prot_t   maxprot;        /</em> maximum VM protection <em>/
vm_prot_t   initprot;       /</em> initial VM protection <em>/
uint32_t    nsects;         /</em> number of sections in segment <em>/
uint32_t    flags;          /</em> flags <a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</div></blockquote>
</section>
<section id="id25">
<h1>};<a class="headerlink" href="#id25" title="Permalink to this headline"></a></h1>
<dl class="simple">
<dt>version_min_command_fields = segment_base_fields + </dt><dd><p>[(“version”, ctypes.c_uint32), (“sdk”, ctypes.c_uint32)]</p>
</dd>
</dl>
<p>“””
struct version_min_command {</p>
<blockquote>
<div><dl class="simple">
<dt>uint32_t    cmd;            /* LC_VERSION_MIN_MACOSX or</dt><dd><p>LC_VERSION_MIN_IPHONEOS or
LC_VERSION_MIN_WATCHOS or
LC_VERSION_MIN_TVOS <a href="#id26"><span class="problematic" id="id27">*</span></a>/</p>
</dd>
</dl>
<p>uint32_t    cmdsize;        /* sizeof(struct min_version_command) <em>/
uint32_t    version;        /</em> X.Y.Z is encoded in nibbles xxxx.yy.zz <em>/
uint32_t    sdk;            /</em> X.Y.Z is encoded in nibbles xxxx.yy.zz <a href="#id28"><span class="problematic" id="id29">*</span></a>/</p>
</div></blockquote>
</section>
<section id="id30">
<h1>};<a class="headerlink" href="#id30" title="Permalink to this headline"></a></h1>
<dl class="simple">
<dt>build_version_command_fields = segment_base_fields + </dt><dd><dl class="simple">
<dt>[(“platform”, ctypes.c_uint32), (“minos”, ctypes.c_uint32),</dt><dd><p>(“sdk”, ctypes.c_uint32), (“ntools”, ctypes.c_uint32)]</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
struct build_version_command {</p>
<blockquote>
<div><p>uint32_t    cmd;            /* LC_BUILD_VERSION <em>/
uint32_t    cmdsize;        /</em> sizeof(struct build_version_command) plus <a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
<blockquote>
<div><p>/* ntools * sizeof(struct build_tool_version) <a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</div></blockquote>
<p>uint32_t    platform;       /* platform <em>/
uint32_t    minos;          /</em> X.Y.Z is encoded in nibbles xxxx.yy.zz <em>/
uint32_t    sdk;            /</em> X.Y.Z is encoded in nibbles xxxx.yy.zz <em>/
uint32_t    ntools;         /</em> number of tool entries following this <a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</div></blockquote>
</section>
<section id="id37">
<h1>};<a class="headerlink" href="#id37" title="Permalink to this headline"></a></h1>
<dl>
<dt>def swap32(x):</dt><dd><dl class="simple">
<dt>return (((x &lt;&lt; 24) &amp; 0xFF000000) |</dt><dd><p>((x &lt;&lt; 8) &amp; 0x00FF0000) |
((x &gt;&gt; 8) &amp; 0x0000FF00) |
((x &gt;&gt; 24) &amp; 0x000000FF))</p>
</dd>
</dl>
</dd>
<dt>def get_base_class_and_magic_number(lib_file, seek=None):</dt><dd><dl class="simple">
<dt>if seek is None:</dt><dd><p>seek = lib_file.tell()</p>
</dd>
<dt>else:</dt><dd><p>lib_file.seek(seek)</p>
</dd>
<dt>magic_number = ctypes.c_uint32.from_buffer_copy(</dt><dd><p>lib_file.read(ctypes.sizeof(ctypes.c_uint32))).value</p>
</dd>
</dl>
<p># Handle wrong byte order
if magic_number in [FAT_CIGAM, FAT_CIGAM_64, MH_CIGAM, MH_CIGAM_64]:</p>
<blockquote>
<div><dl class="simple">
<dt>if sys.byteorder == “little”:</dt><dd><p>BaseClass = ctypes.BigEndianStructure</p>
</dd>
<dt>else:</dt><dd><p>BaseClass = ctypes.LittleEndianStructure</p>
</dd>
</dl>
<p>magic_number = swap32(magic_number)</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>BaseClass = ctypes.Structure</p>
</dd>
</dl>
<p>lib_file.seek(seek)
return BaseClass, magic_number</p>
</dd>
<dt>def read_data(struct_class, lib_file):</dt><dd><dl class="simple">
<dt>return struct_class.from_buffer_copy(lib_file.read(</dt><dd><p>ctypes.sizeof(struct_class)))</p>
</dd>
</dl>
</dd>
<dt>def extract_macosx_min_system_version(path_to_lib):</dt><dd><dl>
<dt>with open(path_to_lib, “rb”) as lib_file:</dt><dd><p>BaseClass, magic_number = get_base_class_and_magic_number(lib_file, 0)
if magic_number not in [FAT_MAGIC, FAT_MAGIC_64, MH_MAGIC, MH_MAGIC_64]:</p>
<blockquote>
<div><p>return</p>
</div></blockquote>
<dl>
<dt>if magic_number in [FAT_MAGIC, FAT_CIGAM_64]:</dt><dd><dl class="simple">
<dt>class FatHeader(BaseClass):</dt><dd><p>_fields_ = fat_header_fields</p>
</dd>
</dl>
<p>fat_header = read_data(FatHeader, lib_file)
if magic_number == FAT_MAGIC:</p>
<blockquote>
<div><dl class="simple">
<dt>class FatArch(BaseClass):</dt><dd><p>_fields_ = fat_arch_fields</p>
</dd>
</dl>
</div></blockquote>
<p>else:</p>
<blockquote>
<div><dl class="simple">
<dt>class FatArch(BaseClass):</dt><dd><p>_fields_ = fat_arch_64_fields</p>
</dd>
</dl>
</div></blockquote>
<p>fat_arch_list = [read_data(FatArch, lib_file) for _ in range(fat_header.nfat_arch)]</p>
<p>versions_list = []
for el in fat_arch_list:</p>
<blockquote>
<div><dl>
<dt>try:</dt><dd><p>version = read_mach_header(lib_file, el.offset)
if version is not None:</p>
<blockquote>
<div><dl>
<dt>if el.cputype == CPU_TYPE_ARM64 and len(fat_arch_list) != 1:</dt><dd><p># Xcode will not set the deployment target below 11.0.0
# for the arm64 architecture. Ignore the arm64 deployment
# in fat binaries when the target is 11.0.0, that way
# the other architectures can select a lower deployment
# target.
# This is safe because there is no arm64 variant for
# macOS 10.15 or earlier.
if version == (11, 0, 0):</p>
<blockquote>
<div><p>continue</p>
</div></blockquote>
</dd>
</dl>
<p>versions_list.append(version)</p>
</div></blockquote>
</dd>
<dt>except ValueError:</dt><dd><p>pass</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>if len(versions_list) &gt; 0:</dt><dd><p>return max(versions_list)</p>
</dd>
<dt>else:</dt><dd><p>return None</p>
</dd>
</dl>
</dd>
<dt>else:</dt><dd><dl class="simple">
<dt>try:</dt><dd><p>return read_mach_header(lib_file, 0)</p>
</dd>
<dt>except ValueError:</dt><dd><p>“””when some error during read library files”””
return None</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>def read_mach_header(lib_file, seek=None):</dt><dd><p>“””
This funcition parse mach-O header and extract
information about minimal system version</p>
<dl class="field-list simple">
<dt class="field-odd">param lib_file</dt>
<dd class="field-odd"><p>reference to opened library file with pointer</p>
</dd>
</dl>
<p>“””
if seek is not None:</p>
<blockquote>
<div><p>lib_file.seek(seek)</p>
</div></blockquote>
<p>base_class, magic_number = get_base_class_and_magic_number(lib_file)
arch = “32” if magic_number == MH_MAGIC else “64”</p>
<dl class="simple">
<dt>class SegmentBase(base_class):</dt><dd><p>_fields_ = segment_base_fields</p>
</dd>
</dl>
<p>if arch == “32”:</p>
<blockquote>
<div><dl class="simple">
<dt>class MachHeader(base_class):</dt><dd><p>_fields_ = mach_header_fields</p>
</dd>
</dl>
</div></blockquote>
<p>else:</p>
<blockquote>
<div><dl class="simple">
<dt>class MachHeader(base_class):</dt><dd><p>_fields_ = mach_header_fields_64</p>
</dd>
</dl>
</div></blockquote>
<p>mach_header = read_data(MachHeader, lib_file)
for _i in range(mach_header.ncmds):</p>
<blockquote>
<div><p>pos = lib_file.tell()
segment_base = read_data(SegmentBase, lib_file)
lib_file.seek(pos)
if segment_base.cmd == LC_VERSION_MIN_MACOSX:</p>
<blockquote>
<div><dl class="simple">
<dt>class VersionMinCommand(base_class):</dt><dd><p>_fields_ = version_min_command_fields</p>
</dd>
</dl>
<p>version_info = read_data(VersionMinCommand, lib_file)
return parse_version(version_info.version)</p>
</div></blockquote>
<dl>
<dt>elif segment_base.cmd == LC_BUILD_VERSION:</dt><dd><dl class="simple">
<dt>class VersionBuild(base_class):</dt><dd><p>_fields_ = build_version_command_fields</p>
</dd>
</dl>
<p>version_info = read_data(VersionBuild, lib_file)
return parse_version(version_info.minos)</p>
</dd>
<dt>else:</dt><dd><p>lib_file.seek(pos + segment_base.cmdsize)
continue</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>def parse_version(version):</dt><dd><p>x = (version &amp; 0xffff0000) &gt;&gt; 16
y = (version &amp; 0x0000ff00) &gt;&gt; 8
z = (version &amp; 0x000000ff)
return x, y, z</p>
</dd>
<dt>def calculate_macosx_platform_tag(archive_root, platform_tag):</dt><dd><p>“””
Calculate proper macosx platform tag basing on files which are included to wheel</p>
<p>Example platform tag <cite>macosx-10.14-x86_64</cite>
“””
prefix, base_version, suffix = platform_tag.split(‘-‘)
base_version = tuple([int(x) for x in base_version.split(“.”)])
base_version = base_version[:2]
if base_version[0] &gt; 10:</p>
<blockquote>
<div><p>base_version = (base_version[0], 0)</p>
</div></blockquote>
<p>assert len(base_version) == 2
if “MACOSX_DEPLOYMENT_TARGET” in os.environ:</p>
<blockquote>
<div><dl class="simple">
<dt>deploy_target = tuple([int(x) for x in os.environ[</dt><dd><p>“MACOSX_DEPLOYMENT_TARGET”].split(“.”)])</p>
</dd>
</dl>
<p>deploy_target = deploy_target[:2]
if deploy_target[0] &gt; 10:</p>
<blockquote>
<div><p>deploy_target = (deploy_target[0], 0)</p>
</div></blockquote>
<dl>
<dt>if deploy_target &lt; base_version:</dt><dd><dl>
<dt>sys.stderr.write(</dt><dd><blockquote>
<div><p>“[WARNING] MACOSX_DEPLOYMENT_TARGET is set to a lower value ({}) than the ”
“version on which the Python interpreter was compiled ({}), and will be ”
“ignored.n”.format(‘.’.join(str(x) for x in deploy_target),</p>
<blockquote>
<div><p>‘.’.join(str(x) for x in base_version))</p>
</div></blockquote>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</dd>
<dt>else:</dt><dd><p>base_version = deploy_target</p>
</dd>
</dl>
</div></blockquote>
<p>assert len(base_version) == 2
start_version = base_version
versions_dict = {}
for (dirpath, dirnames, filenames) in os.walk(archive_root):</p>
<blockquote>
<div><dl>
<dt>for filename in filenames:</dt><dd><dl>
<dt>if filename.endswith(‘.dylib’) or filename.endswith(‘.so’):</dt><dd><p>lib_path = os.path.join(dirpath, filename)
min_ver = extract_macosx_min_system_version(lib_path)
if min_ver is not None:</p>
<blockquote>
<div><p>min_ver = min_ver[0:2]
if min_ver[0] &gt; 10:</p>
<blockquote>
<div><p>min_ver = (min_ver[0], 0)</p>
</div></blockquote>
<p>versions_dict[lib_path] = min_ver</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>if len(versions_dict) &gt; 0:</dt><dd><p>base_version = max(base_version, max(versions_dict.values()))</p>
</dd>
</dl>
<p># macosx platform tag do not support minor bugfix release
fin_base_version = “_”.join([str(x) for x in base_version])
if start_version &lt; base_version:</p>
<blockquote>
<div><p>problematic_files = [k for k, v in versions_dict.items() if v &gt; start_version]
problematic_files = “n”.join(problematic_files)
if len(problematic_files) == 1:</p>
<blockquote>
<div><p>files_form = “this file”</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>files_form = “these files”</p>
</dd>
<dt>error_message = </dt><dd><p>“[WARNING] This wheel needs a higher macOS version than {}  ” “To silence this warning, set MACOSX_DEPLOYMENT_TARGET to at least ” +fin_base_version + ” or recreate ” + files_form + ” with lower ” “MACOSX_DEPLOYMENT_TARGET:  n” + problematic_files</p>
</dd>
<dt>if “MACOSX_DEPLOYMENT_TARGET” in os.environ:</dt><dd><p>error_message = error_message.format(“is set in MACOSX_DEPLOYMENT_TARGET variable.”)</p>
</dd>
<dt>else:</dt><dd><dl class="simple">
<dt>error_message = error_message.format(</dt><dd><p>“the version your Python interpreter is compiled against.”)</p>
</dd>
</dl>
</dd>
</dl>
<p>sys.stderr.write(error_message)</p>
</div></blockquote>
<p>platform_tag = prefix + “_” + fin_base_version + “_” + suffix
return platform_tag</p>
</dd>
</dl>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, hrishabh kamal.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>