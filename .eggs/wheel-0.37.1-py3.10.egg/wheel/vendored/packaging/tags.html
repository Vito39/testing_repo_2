<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Polly_Documentation 1 documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../../index.html" class="icon icon-home"> Polly_Documentation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../polly.html">polly package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">Polly_Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../_sources/.eggs/wheel-0.37.1-py3.10.egg/wheel/vendored/packaging/tags.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p># This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.</p>
<p>from __future__ import absolute_import</p>
<p>import distutils.util</p>
<dl>
<dt>try:</dt><dd><p>from importlib.machinery import EXTENSION_SUFFIXES</p>
</dd>
<dt>except ImportError:  # pragma: no cover</dt><dd><p>import imp</p>
<p>EXTENSION_SUFFIXES = [x[0] for x in imp.get_suffixes()]
del imp</p>
</dd>
</dl>
<p>import collections
import logging
import os
import platform
import re
import struct
import sys
import sysconfig
import warnings</p>
<p>from ._typing import TYPE_CHECKING, cast</p>
<dl>
<dt>if TYPE_CHECKING:  # pragma: no cover</dt><dd><dl class="simple">
<dt>from typing import (</dt><dd><p>Dict,
FrozenSet,
IO,
Iterable,
Iterator,
List,
Optional,
Sequence,
Tuple,
Union,</p>
</dd>
</dl>
<p>)</p>
<p>PythonVersion = Sequence[int]
MacVersion = Tuple[int, int]
GlibcVersion = Tuple[int, int]</p>
</dd>
</dl>
<p>logger = logging.getLogger(__name__)</p>
<dl class="simple">
<dt>INTERPRETER_SHORT_NAMES = {</dt><dd><p>“python”: “py”,  # Generic.
“cpython”: “cp”,
“pypy”: “pp”,
“ironpython”: “ip”,
“jython”: “jy”,</p>
</dd>
</dl>
<p>}  # type: Dict[str, str]</p>
<p>_32_BIT_INTERPRETER = sys.maxsize &lt;= 2 ** 32</p>
<dl class="simple">
<dt>_LEGACY_MANYLINUX_MAP = {</dt><dd><p># CentOS 7 w/ glibc 2.17 (PEP 599)
(2, 17): “manylinux2014”,
# CentOS 6 w/ glibc 2.12 (PEP 571)
(2, 12): “manylinux2010”,
# CentOS 5 w/ glibc 2.5 (PEP 513)
(2, 5): “manylinux1”,</p>
</dd>
</dl>
<p>}</p>
<p># If glibc ever changes its major version, we need to know what the last
# minor version was, so we can build the complete list of all versions.
# For now, guess what the highest minor version might be, assume it will
# be 50 for testing. Once this actually happens, update the dictionary
# with the actual value.
_LAST_GLIBC_MINOR = collections.defaultdict(lambda: 50)  # type: Dict[int, int]
glibcVersion = collections.namedtuple(“Version”, [“major”, “minor”])</p>
<dl>
<dt>class Tag(object):</dt><dd><p>“””
A representation of the tag triple for a wheel.</p>
<p>Instances are considered immutable and thus are hashable. Equality checking
is also supported.
“””</p>
<p>__slots__ = [“_interpreter”, “_abi”, “_platform”, “_hash”]</p>
<dl class="simple">
<dt>def __init__(self, interpreter, abi, platform):</dt><dd><p># type: (str, str, str) -&gt; None
self._interpreter = interpreter.lower()
self._abi = abi.lower()
self._platform = platform.lower()
# The __hash__ of every single element in a Set[Tag] will be evaluated each time
# that a set calls its <cite>.disjoint()</cite> method, which may be called hundreds of
# times when scanning a page of links for packages with tags matching that
# Set[Tag]. Pre-computing the value here produces significant speedups for
# downstream consumers.
self._hash = hash((self._interpreter, self._abi, self._platform))</p>
</dd>
</dl>
<p>&#64;property
def interpreter(self):</p>
<blockquote>
<div><p># type: () -&gt; str
return self._interpreter</p>
</div></blockquote>
<p>&#64;property
def abi(self):</p>
<blockquote>
<div><p># type: () -&gt; str
return self._abi</p>
</div></blockquote>
<p>&#64;property
def platform(self):</p>
<blockquote>
<div><p># type: () -&gt; str
return self._platform</p>
</div></blockquote>
<dl>
<dt>def __eq__(self, other):</dt><dd><p># type: (object) -&gt; bool
if not isinstance(other, Tag):</p>
<blockquote>
<div><p>return NotImplemented</p>
</div></blockquote>
<dl class="simple">
<dt>return (</dt><dd><p>(self.platform == other.platform)
and (self.abi == other.abi)
and (self.interpreter == other.interpreter)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def __hash__(self):</dt><dd><p># type: () -&gt; int
return self._hash</p>
</dd>
<dt>def __str__(self):</dt><dd><p># type: () -&gt; str
return “{}-{}-{}”.format(self._interpreter, self._abi, self._platform)</p>
</dd>
<dt>def __repr__(self):</dt><dd><p># type: () -&gt; str
return “&lt;{self} &#64; {self_id}&gt;”.format(self=self, self_id=id(self))</p>
</dd>
</dl>
</dd>
<dt>def parse_tag(tag):</dt><dd><p># type: (str) -&gt; FrozenSet[Tag]
“””
Parses the provided tag (e.g. <cite>py3-none-any</cite>) into a frozenset of Tag instances.</p>
<p>Returning a set is required due to the possibility that the tag is a
compressed tag set.
“””
tags = set()
interpreters, abis, platforms = tag.split(“-“)
for interpreter in interpreters.split(“.”):</p>
<blockquote>
<div><dl class="simple">
<dt>for abi in abis.split(“.”):</dt><dd><dl class="simple">
<dt>for <a href="#id13"><span class="problematic" id="id14">platform_</span></a> in platforms.split(“.”):</dt><dd><p>tags.add(Tag(interpreter, abi, <a href="#id15"><span class="problematic" id="id16">platform_</span></a>))</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>return frozenset(tags)</p>
</dd>
<dt>def _warn_keyword_parameter(func_name, kwargs):</dt><dd><p># type: (str, Dict[str, bool]) -&gt; bool
“””
Backwards-compatibility with Python 2.7 to allow treating ‘warn’ as keyword-only.
“””
if not kwargs:</p>
<blockquote>
<div><p>return False</p>
</div></blockquote>
<dl>
<dt>elif len(kwargs) &gt; 1 or “warn” not in kwargs:</dt><dd><p>kwargs.pop(“warn”, None)
arg = next(iter(kwargs.keys()))
raise TypeError(</p>
<blockquote>
<div><p>“{}() got an unexpected keyword argument {!r}”.format(func_name, arg)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>return kwargs[“warn”]</p>
</dd>
<dt>def _get_config_var(name, warn=False):</dt><dd><p># type: (str, bool) -&gt; Union[int, str, None]
value = sysconfig.get_config_var(name)
if value is None and warn:</p>
<blockquote>
<div><dl class="simple">
<dt>logger.debug(</dt><dd><p>“Config variable ‘%s’ is unset, Python ABI tag may be incorrect”, name</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>return value</p>
</dd>
<dt>def _normalize_string(string):</dt><dd><p># type: (str) -&gt; str
return string.replace(“.”, “_”).replace(“-”, “_”)</p>
</dd>
<dt>def _abi3_applies(python_version):</dt><dd><p># type: (PythonVersion) -&gt; bool
“””
Determine if the Python version supports abi3.</p>
<p>PEP 384 was first implemented in Python 3.2.
“””
return len(python_version) &gt; 1 and tuple(python_version) &gt;= (3, 2)</p>
</dd>
<dt>def _cpython_abis(py_version, warn=False):</dt><dd><p># type: (PythonVersion, bool) -&gt; List[str]
py_version = tuple(py_version)  # To allow for version comparison.
abis = []
version = _version_nodot(py_version[:2])
debug = pymalloc = ucs4 = “”
with_debug = _get_config_var(“Py_DEBUG”, warn)
has_refcount = hasattr(sys, “gettotalrefcount”)
# Windows doesn’t set Py_DEBUG, so checking for support of debug-compiled
# extension modules is the best option.
# <a class="reference external" href="https://github.com/pypa/pip/issues/3383#issuecomment-173267692">https://github.com/pypa/pip/issues/3383#issuecomment-173267692</a>
has_ext = “_d.pyd” in EXTENSION_SUFFIXES
if with_debug or (with_debug is None and (has_refcount or has_ext)):</p>
<blockquote>
<div><p>debug = “d”</p>
</div></blockquote>
<dl>
<dt>if py_version &lt; (3, 8):</dt><dd><p>with_pymalloc = _get_config_var(“WITH_PYMALLOC”, warn)
if with_pymalloc or with_pymalloc is None:</p>
<blockquote>
<div><p>pymalloc = “m”</p>
</div></blockquote>
<dl>
<dt>if py_version &lt; (3, 3):</dt><dd><p>unicode_size = _get_config_var(“Py_UNICODE_SIZE”, warn)
if unicode_size == 4 or (</p>
<blockquote>
<div><p>unicode_size is None and sys.maxunicode == 0x10FFFF</p>
</div></blockquote>
<dl class="simple">
<dt>):</dt><dd><p>ucs4 = “u”</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>elif debug:</dt><dd><p># Debug builds can also load “normal” extension modules.
# We can also assume no UCS-4 or pymalloc requirement.
abis.append(“cp{version}”.format(version=version))</p>
</dd>
<dt>abis.insert(</dt><dd><p>0,
“cp{version}{debug}{pymalloc}{ucs4}”.format(</p>
<blockquote>
<div><p>version=version, debug=debug, pymalloc=pymalloc, ucs4=ucs4</p>
</div></blockquote>
<p>),</p>
</dd>
</dl>
<p>)
return abis</p>
</dd>
<dt>def cpython_tags(</dt><dd><p>python_version=None,  # type: Optional[PythonVersion]
abis=None,  # type: Optional[Iterable[str]]
platforms=None,  # type: Optional[Iterable[str]]
<a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs  # type: bool</p>
</dd>
<dt>):</dt><dd><p># type: (…) -&gt; Iterator[Tag]
“””
Yields the tags for a CPython interpreter.</p>
<p>The tags consist of:
- cp&lt;python_version&gt;-&lt;abi&gt;-&lt;platform&gt;
- cp&lt;python_version&gt;-abi3-&lt;platform&gt;
- cp&lt;python_version&gt;-none-&lt;platform&gt;
- cp&lt;less than python_version&gt;-abi3-&lt;platform&gt;  # Older Python versions down to 3.2.</p>
<p>If python_version only specifies a major version then user-provided ABIs and
the ‘none’ ABItag will be used.</p>
<p>If ‘abi3’ or ‘none’ are specified in ‘abis’ then they will be yielded at
their normal position and not at the beginning.
“””
warn = _warn_keyword_parameter(“cpython_tags”, kwargs)
if not python_version:</p>
<blockquote>
<div><p>python_version = sys.version_info[:2]</p>
</div></blockquote>
<p>interpreter = “cp{}”.format(_version_nodot(python_version[:2]))</p>
<dl class="simple">
<dt>if abis is None:</dt><dd><dl class="simple">
<dt>if len(python_version) &gt; 1:</dt><dd><p>abis = _cpython_abis(python_version, warn)</p>
</dd>
<dt>else:</dt><dd><p>abis = []</p>
</dd>
</dl>
</dd>
</dl>
<p>abis = list(abis)
# ‘abi3’ and ‘none’ are explicitly handled later.
for explicit_abi in (“abi3”, “none”):</p>
<blockquote>
<div><dl class="simple">
<dt>try:</dt><dd><p>abis.remove(explicit_abi)</p>
</dd>
<dt>except ValueError:</dt><dd><p>pass</p>
</dd>
</dl>
</div></blockquote>
<p>platforms = list(platforms or _platform_tags())
for abi in abis:</p>
<blockquote>
<div><dl class="simple">
<dt>for <a href="#id17"><span class="problematic" id="id18">platform_</span></a> in platforms:</dt><dd><p>yield Tag(interpreter, abi, <a href="#id19"><span class="problematic" id="id20">platform_</span></a>)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>if _abi3_applies(python_version):</dt><dd><dl class="simple">
<dt>for tag in (Tag(interpreter, “abi3”, <a href="#id21"><span class="problematic" id="id22">platform_</span></a>) for <a href="#id23"><span class="problematic" id="id24">platform_</span></a> in platforms):</dt><dd><p>yield tag</p>
</dd>
</dl>
</dd>
<dt>for tag in (Tag(interpreter, “none”, <a href="#id25"><span class="problematic" id="id26">platform_</span></a>) for <a href="#id27"><span class="problematic" id="id28">platform_</span></a> in platforms):</dt><dd><p>yield tag</p>
</dd>
<dt>if _abi3_applies(python_version):</dt><dd><dl>
<dt>for minor_version in range(python_version[1] - 1, 1, -1):</dt><dd><dl>
<dt>for <a href="#id29"><span class="problematic" id="id30">platform_</span></a> in platforms:</dt><dd><dl class="simple">
<dt>interpreter = “cp{version}”.format(</dt><dd><p>version=_version_nodot((python_version[0], minor_version))</p>
</dd>
</dl>
<p>)
yield Tag(interpreter, “abi3”, <a href="#id31"><span class="problematic" id="id32">platform_</span></a>)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>def _generic_abi():</dt><dd><p># type: () -&gt; Iterator[str]
abi = sysconfig.get_config_var(“SOABI”)
if abi:</p>
<blockquote>
<div><p>yield _normalize_string(abi)</p>
</div></blockquote>
</dd>
<dt>def generic_tags(</dt><dd><p>interpreter=None,  # type: Optional[str]
abis=None,  # type: Optional[Iterable[str]]
platforms=None,  # type: Optional[Iterable[str]]
<a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs  # type: bool</p>
</dd>
<dt>):</dt><dd><p># type: (…) -&gt; Iterator[Tag]
“””
Yields the tags for a generic interpreter.</p>
<p>The tags consist of:
- &lt;interpreter&gt;-&lt;abi&gt;-&lt;platform&gt;</p>
<p>The “none” ABI will be added if it was not explicitly provided.
“””
warn = _warn_keyword_parameter(“generic_tags”, kwargs)
if not interpreter:</p>
<blockquote>
<div><p>interp_name = interpreter_name()
interp_version = interpreter_version(warn=warn)
interpreter = “”.join([interp_name, interp_version])</p>
</div></blockquote>
<dl class="simple">
<dt>if abis is None:</dt><dd><p>abis = _generic_abi()</p>
</dd>
</dl>
<p>platforms = list(platforms or _platform_tags())
abis = list(abis)
if “none” not in abis:</p>
<blockquote>
<div><p>abis.append(“none”)</p>
</div></blockquote>
<dl class="simple">
<dt>for abi in abis:</dt><dd><dl class="simple">
<dt>for <a href="#id33"><span class="problematic" id="id34">platform_</span></a> in platforms:</dt><dd><p>yield Tag(interpreter, abi, <a href="#id35"><span class="problematic" id="id36">platform_</span></a>)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>def _py_interpreter_range(py_version):</dt><dd><p># type: (PythonVersion) -&gt; Iterator[str]
“””
Yields Python versions in descending order.</p>
<p>After the latest version, the major-only version will be yielded, and then
all previous versions of that major version.
“””
if len(py_version) &gt; 1:</p>
<blockquote>
<div><p>yield “py{version}”.format(version=_version_nodot(py_version[:2]))</p>
</div></blockquote>
<p>yield “py{major}”.format(major=py_version[0])
if len(py_version) &gt; 1:</p>
<blockquote>
<div><dl class="simple">
<dt>for minor in range(py_version[1] - 1, -1, -1):</dt><dd><p>yield “py{version}”.format(version=_version_nodot((py_version[0], minor)))</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>def compatible_tags(</dt><dd><p>python_version=None,  # type: Optional[PythonVersion]
interpreter=None,  # type: Optional[str]
platforms=None,  # type: Optional[Iterable[str]]</p>
</dd>
<dt>):</dt><dd><p># type: (…) -&gt; Iterator[Tag]
“””
Yields the sequence of tags that are compatible with a specific version of Python.</p>
<p>The tags consist of:
- py*-none-&lt;platform&gt;
- &lt;interpreter&gt;-none-any  # … if <cite>interpreter</cite> is provided.
- py*-none-any
“””
if not python_version:</p>
<blockquote>
<div><p>python_version = sys.version_info[:2]</p>
</div></blockquote>
<p>platforms = list(platforms or _platform_tags())
for version in _py_interpreter_range(python_version):</p>
<blockquote>
<div><dl class="simple">
<dt>for <a href="#id37"><span class="problematic" id="id38">platform_</span></a> in platforms:</dt><dd><p>yield Tag(version, “none”, <a href="#id39"><span class="problematic" id="id40">platform_</span></a>)</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>if interpreter:</dt><dd><p>yield Tag(interpreter, “none”, “any”)</p>
</dd>
<dt>for version in _py_interpreter_range(python_version):</dt><dd><p>yield Tag(version, “none”, “any”)</p>
</dd>
</dl>
</dd>
<dt>def _mac_arch(arch, is_32bit=_32_BIT_INTERPRETER):</dt><dd><p># type: (str, bool) -&gt; str
if not is_32bit:</p>
<blockquote>
<div><p>return arch</p>
</div></blockquote>
<dl class="simple">
<dt>if arch.startswith(“ppc”):</dt><dd><p>return “ppc”</p>
</dd>
</dl>
<p>return “i386”</p>
</dd>
<dt>def _mac_binary_formats(version, cpu_arch):</dt><dd><p># type: (MacVersion, str) -&gt; List[str]
formats = [cpu_arch]
if cpu_arch == “x86_64”:</p>
<blockquote>
<div><dl class="simple">
<dt>if version &lt; (10, 4):</dt><dd><p>return []</p>
</dd>
</dl>
<p>formats.extend([“intel”, “fat64”, “fat32”])</p>
</div></blockquote>
<dl>
<dt>elif cpu_arch == “i386”:</dt><dd><dl class="simple">
<dt>if version &lt; (10, 4):</dt><dd><p>return []</p>
</dd>
</dl>
<p>formats.extend([“intel”, “fat32”, “fat”])</p>
</dd>
<dt>elif cpu_arch == “ppc64”:</dt><dd><p># TODO: Need to care about 32-bit PPC for ppc64 through 10.2?
if version &gt; (10, 5) or version &lt; (10, 4):</p>
<blockquote>
<div><p>return []</p>
</div></blockquote>
<p>formats.append(“fat64”)</p>
</dd>
<dt>elif cpu_arch == “ppc”:</dt><dd><dl class="simple">
<dt>if version &gt; (10, 6):</dt><dd><p>return []</p>
</dd>
</dl>
<p>formats.extend([“fat32”, “fat”])</p>
</dd>
<dt>if cpu_arch in {“arm64”, “x86_64”}:</dt><dd><p>formats.append(“universal2”)</p>
</dd>
<dt>if cpu_arch in {“x86_64”, “i386”, “ppc64”, “ppc”, “intel”}:</dt><dd><p>formats.append(“universal”)</p>
</dd>
</dl>
<p>return formats</p>
</dd>
<dt>def mac_platforms(version=None, arch=None):</dt><dd><p># type: (Optional[MacVersion], Optional[str]) -&gt; Iterator[str]
“””
Yields the platform tags for a macOS system.</p>
<p>The <cite>version</cite> parameter is a two-item tuple specifying the macOS version to
generate platform tags for. The <cite>arch</cite> parameter is the CPU architecture to
generate platform tags for. Both parameters default to the appropriate value
for the current system.
“””
version_str, _, cpu_arch = platform.mac_ver()  # type: ignore
if version is None:</p>
<blockquote>
<div><p>version = cast(“MacVersion”, tuple(map(int, version_str.split(“.”)[:2])))</p>
</div></blockquote>
<dl>
<dt>else:</dt><dd><p>version = version</p>
</dd>
<dt>if arch is None:</dt><dd><p>arch = _mac_arch(cpu_arch)</p>
</dd>
<dt>else:</dt><dd><p>arch = arch</p>
</dd>
<dt>if (10, 0) &lt;= version and version &lt; (11, 0):</dt><dd><p># Prior to Mac OS 11, each yearly release of Mac OS bumped the
# “minor” version number.  The major version was always 10.
for minor_version in range(version[1], -1, -1):</p>
<blockquote>
<div><p>compat_version = 10, minor_version
binary_formats = _mac_binary_formats(compat_version, arch)
for binary_format in binary_formats:</p>
<blockquote>
<div><dl class="simple">
<dt>yield “macosx_{major}_{minor}_{binary_format}”.format(</dt><dd><p>major=10, minor=minor_version, binary_format=binary_format</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</div></blockquote>
</dd>
<dt>if version &gt;= (11, 0):</dt><dd><p># Starting with Mac OS 11, each yearly release bumps the major version
# number.   The minor versions are now the midyear updates.
for major_version in range(version[0], 10, -1):</p>
<blockquote>
<div><p>compat_version = major_version, 0
binary_formats = _mac_binary_formats(compat_version, arch)
for binary_format in binary_formats:</p>
<blockquote>
<div><dl class="simple">
<dt>yield “macosx_{major}_{minor}_{binary_format}”.format(</dt><dd><p>major=major_version, minor=0, binary_format=binary_format</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</div></blockquote>
</dd>
<dt>if version &gt;= (11, 0):</dt><dd><p># Mac OS 11 on x86_64 is compatible with binaries from previous releases.
# Arm64 support was introduced in 11.0, so no Arm binaries from previous
# releases exist.
#
# However, the “universal2” binary format can have a
# macOS version earlier than 11.0 when the x86_64 part of the binary supports
# that version of macOS.
if arch == “x86_64”:</p>
<blockquote>
<div><dl>
<dt>for minor_version in range(16, 3, -1):</dt><dd><p>compat_version = 10, minor_version
binary_formats = _mac_binary_formats(compat_version, arch)
for binary_format in binary_formats:</p>
<blockquote>
<div><dl class="simple">
<dt>yield “macosx_{major}_{minor}_{binary_format}”.format(</dt><dd><p>major=compat_version[0],
minor=compat_version[1],
binary_format=binary_format,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>else:</dt><dd><dl>
<dt>for minor_version in range(16, 3, -1):</dt><dd><p>compat_version = 10, minor_version
binary_format = “universal2”
yield “macosx_{major}_{minor}_{binary_format}”.format(</p>
<blockquote>
<div><p>major=compat_version[0],
minor=compat_version[1],
binary_format=binary_format,</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p># From PEP 513, PEP 600
def _is_manylinux_compatible(name, arch, glibc_version):</p>
<blockquote>
<div><p># type: (str, str, GlibcVersion) -&gt; bool
sys_glibc = _get_glibc_version()
if sys_glibc &lt; glibc_version:</p>
<blockquote>
<div><p>return False</p>
</div></blockquote>
<p># Check for presence of _manylinux module.
try:</p>
<blockquote>
<div><p>import _manylinux  # noqa</p>
</div></blockquote>
<dl>
<dt>except ImportError:</dt><dd><p>pass</p>
</dd>
<dt>else:</dt><dd><dl>
<dt>if hasattr(_manylinux, “manylinux_compatible”):</dt><dd><dl class="simple">
<dt>result = _manylinux.manylinux_compatible(</dt><dd><p>glibc_version[0], glibc_version[1], arch</p>
</dd>
</dl>
<p>)
if result is not None:</p>
<blockquote>
<div><p>return bool(result)</p>
</div></blockquote>
</dd>
<dt>else:</dt><dd><dl class="simple">
<dt>if glibc_version == (2, 5):</dt><dd><dl class="simple">
<dt>if hasattr(_manylinux, “manylinux1_compatible”):</dt><dd><p>return bool(_manylinux.manylinux1_compatible)</p>
</dd>
</dl>
</dd>
<dt>if glibc_version == (2, 12):</dt><dd><dl class="simple">
<dt>if hasattr(_manylinux, “manylinux2010_compatible”):</dt><dd><p>return bool(_manylinux.manylinux2010_compatible)</p>
</dd>
</dl>
</dd>
<dt>if glibc_version == (2, 17):</dt><dd><dl class="simple">
<dt>if hasattr(_manylinux, “manylinux2014_compatible”):</dt><dd><p>return bool(_manylinux.manylinux2014_compatible)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>return True</p>
</div></blockquote>
<dl>
<dt>def _glibc_version_string():</dt><dd><p># type: () -&gt; Optional[str]
# Returns glibc version string, or None if not using glibc.
return _glibc_version_string_confstr() or _glibc_version_string_ctypes()</p>
</dd>
<dt>def _glibc_version_string_confstr():</dt><dd><p># type: () -&gt; Optional[str]
“””
Primary implementation of glibc_version_string using os.confstr.
“””
# os.confstr is quite a bit faster than ctypes.DLL. It’s also less likely
# to be broken or missing. This strategy is used in the standard library
# platform module.
# <a class="reference external" href="https://github.com/python/cpython/blob/fcf1d003bf4f0100c9d0921ff3d70e1127ca1b71/Lib/platform.py#L175-L183">https://github.com/python/cpython/blob/fcf1d003bf4f0100c9d0921ff3d70e1127ca1b71/Lib/platform.py#L175-L183</a>
try:</p>
<blockquote>
<div><p># os.confstr(“CS_GNU_LIBC_VERSION”) returns a string like “glibc 2.17”.
version_string = os.confstr(  # type: ignore[attr-defined] # noqa: F821</p>
<blockquote>
<div><p>“CS_GNU_LIBC_VERSION”</p>
</div></blockquote>
<p>)
assert version_string is not None
_, version = version_string.split()  # type: Tuple[str, str]</p>
</div></blockquote>
<dl class="simple">
<dt>except (AssertionError, AttributeError, OSError, ValueError):</dt><dd><p># os.confstr() or CS_GNU_LIBC_VERSION not available (or a bad value)…
return None</p>
</dd>
</dl>
<p>return version</p>
</dd>
<dt>def _glibc_version_string_ctypes():</dt><dd><p># type: () -&gt; Optional[str]
“””
Fallback implementation of glibc_version_string using ctypes.
“””
try:</p>
<blockquote>
<div><p>import ctypes</p>
</div></blockquote>
<dl class="simple">
<dt>except ImportError:</dt><dd><p>return None</p>
</dd>
</dl>
<p># ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen
# manpage says, “If filename is NULL, then the returned handle is for the
# main program”. This way we can let the linker do the work to figure out
# which libc our process is actually using.
#
# We must also handle the special case where the executable is not a
# dynamically linked executable. This can occur when using musl libc,
# for example. In this situation, dlopen() will error, leading to an
# OSError. Interestingly, at least in the case of musl, there is no
# errno set on the OSError. The single string argument used to construct
# OSError comes from libc itself and is therefore not portable to
# hard code here. In any case, failure to call dlopen() means we
# can proceed, so we bail on our attempt.
try:</p>
<blockquote>
<div><p># Note: typeshed is wrong here so we are ignoring this line.
process_namespace = ctypes.CDLL(None)  # type: ignore</p>
</div></blockquote>
<dl class="simple">
<dt>except OSError:</dt><dd><p>return None</p>
</dd>
<dt>try:</dt><dd><p>gnu_get_libc_version = process_namespace.gnu_get_libc_version</p>
</dd>
<dt>except AttributeError:</dt><dd><p># Symbol doesn’t exist -&gt; therefore, we are not linked to
# glibc.
return None</p>
</dd>
</dl>
<p># Call gnu_get_libc_version, which returns a string like “2.5”
gnu_get_libc_version.restype = ctypes.c_char_p
version_str = gnu_get_libc_version()  # type: str
# py2 / py3 compatibility:
if not isinstance(version_str, str):</p>
<blockquote>
<div><p>version_str = version_str.decode(“ascii”)</p>
</div></blockquote>
<p>return version_str</p>
</dd>
<dt>def _parse_glibc_version(version_str):</dt><dd><p># type: (str) -&gt; Tuple[int, int]
# Parse glibc version.
#
# We use a regexp instead of str.split because we want to discard any
# random junk that might come after the minor version – this might happen
# in patched/forked versions of glibc (e.g. Linaro’s version of glibc
# uses version strings like “2.20-2014.11”). See gh-3588.
m = re.match(r”(?P&lt;major&gt;[0-9]+).(?P&lt;minor&gt;[0-9]+)”, version_str)
if not m:</p>
<blockquote>
<div><dl class="simple">
<dt>warnings.warn(</dt><dd><p>“Expected glibc version with 2 components major.minor,”
” got: %s” % version_str,
RuntimeWarning,</p>
</dd>
</dl>
<p>)
return -1, -1</p>
</div></blockquote>
<p>return (int(m.group(“major”)), int(m.group(“minor”)))</p>
</dd>
</dl>
<p>_glibc_version = []  # type: List[Tuple[int, int]]</p>
<dl>
<dt>def _get_glibc_version():</dt><dd><p># type: () -&gt; Tuple[int, int]
if _glibc_version:</p>
<blockquote>
<div><p>return _glibc_version[0]</p>
</div></blockquote>
<p>version_str = _glibc_version_string()
if version_str is None:</p>
<blockquote>
<div><p>_glibc_version.append((-1, -1))</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>_glibc_version.append(_parse_glibc_version(version_str))</p>
</dd>
</dl>
<p>return _glibc_version[0]</p>
</dd>
</dl>
<p># Python does not provide platform information at sufficient granularity to
# identify the architecture of the running executable in some cases, so we
# determine it dynamically by reading the information from the running
# process. This only applies on Linux, which uses the ELF format.
class _ELFFileHeader(object):</p>
<blockquote>
<div><p># <a class="reference external" href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#File_header">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#File_header</a>
class _InvalidELFFileHeader(ValueError):</p>
<blockquote>
<div><p>“””
An invalid ELF file header was found.
“””</p>
</div></blockquote>
<p>ELF_MAGIC_NUMBER = 0x7F454C46
ELFCLASS32 = 1
ELFCLASS64 = 2
ELFDATA2LSB = 1
ELFDATA2MSB = 2
EM_386 = 3
EM_S390 = 22
EM_ARM = 40
EM_X86_64 = 62
EF_ARM_ABIMASK = 0xFF000000
EF_ARM_ABI_VER5 = 0x05000000
EF_ARM_ABI_FLOAT_HARD = 0x00000400</p>
<dl>
<dt>def __init__(self, file):</dt><dd><p># type: (IO[bytes]) -&gt; None
def unpack(fmt):</p>
<blockquote>
<div><p># type: (str) -&gt; int
try:</p>
<blockquote>
<div><dl class="simple">
<dt>(result,) = struct.unpack(</dt><dd><p>fmt, file.read(struct.calcsize(fmt))</p>
</dd>
</dl>
<p>)  # type: (int, )</p>
</div></blockquote>
<dl class="simple">
<dt>except struct.error:</dt><dd><p>raise _ELFFileHeader._InvalidELFFileHeader()</p>
</dd>
</dl>
<p>return result</p>
</div></blockquote>
<p>self.e_ident_magic = unpack(“&gt;I”)
if self.e_ident_magic != self.ELF_MAGIC_NUMBER:</p>
<blockquote>
<div><p>raise _ELFFileHeader._InvalidELFFileHeader()</p>
</div></blockquote>
<p>self.e_ident_class = unpack(“B”)
if self.e_ident_class not in {self.ELFCLASS32, self.ELFCLASS64}:</p>
<blockquote>
<div><p>raise _ELFFileHeader._InvalidELFFileHeader()</p>
</div></blockquote>
<p>self.e_ident_data = unpack(“B”)
if self.e_ident_data not in {self.ELFDATA2LSB, self.ELFDATA2MSB}:</p>
<blockquote>
<div><p>raise _ELFFileHeader._InvalidELFFileHeader()</p>
</div></blockquote>
<p>self.e_ident_version = unpack(“B”)
self.e_ident_osabi = unpack(“B”)
self.e_ident_abiversion = unpack(“B”)
self.e_ident_pad = file.read(7)
format_h = “&lt;H” if self.e_ident_data == self.ELFDATA2LSB else “&gt;H”
format_i = “&lt;I” if self.e_ident_data == self.ELFDATA2LSB else “&gt;I”
format_q = “&lt;Q” if self.e_ident_data == self.ELFDATA2LSB else “&gt;Q”
format_p = format_i if self.e_ident_class == self.ELFCLASS32 else format_q
self.e_type = unpack(format_h)
self.e_machine = unpack(format_h)
self.e_version = unpack(format_i)
self.e_entry = unpack(format_p)
self.e_phoff = unpack(format_p)
self.e_shoff = unpack(format_p)
self.e_flags = unpack(format_i)
self.e_ehsize = unpack(format_h)
self.e_phentsize = unpack(format_h)
self.e_phnum = unpack(format_h)
self.e_shentsize = unpack(format_h)
self.e_shnum = unpack(format_h)
self.e_shstrndx = unpack(format_h)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>def _get_elf_header():</dt><dd><p># type: () -&gt; Optional[_ELFFileHeader]
try:</p>
<blockquote>
<div><dl class="simple">
<dt>with open(sys.executable, “rb”) as f:</dt><dd><p>elf_header = _ELFFileHeader(f)</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>except (IOError, OSError, TypeError, _ELFFileHeader._InvalidELFFileHeader):</dt><dd><p>return None</p>
</dd>
</dl>
<p>return elf_header</p>
</dd>
<dt>def _is_linux_armhf():</dt><dd><p># type: () -&gt; bool
# hard-float ABI can be detected from the ELF header of the running
# process
# <a class="reference external" href="https://static.docs.arm.com/ihi0044/g/aaelf32.pdf">https://static.docs.arm.com/ihi0044/g/aaelf32.pdf</a>
elf_header = _get_elf_header()
if elf_header is None:</p>
<blockquote>
<div><p>return False</p>
</div></blockquote>
<p>result = elf_header.e_ident_class == elf_header.ELFCLASS32
result &amp;= elf_header.e_ident_data == elf_header.ELFDATA2LSB
result &amp;= elf_header.e_machine == elf_header.EM_ARM
result &amp;= (</p>
<blockquote>
<div><p>elf_header.e_flags &amp; elf_header.EF_ARM_ABIMASK</p>
</div></blockquote>
<p>) == elf_header.EF_ARM_ABI_VER5
result &amp;= (</p>
<blockquote>
<div><p>elf_header.e_flags &amp; elf_header.EF_ARM_ABI_FLOAT_HARD</p>
</div></blockquote>
<p>) == elf_header.EF_ARM_ABI_FLOAT_HARD
return result</p>
</dd>
<dt>def _is_linux_i686():</dt><dd><p># type: () -&gt; bool
elf_header = _get_elf_header()
if elf_header is None:</p>
<blockquote>
<div><p>return False</p>
</div></blockquote>
<p>result = elf_header.e_ident_class == elf_header.ELFCLASS32
result &amp;= elf_header.e_ident_data == elf_header.ELFDATA2LSB
result &amp;= elf_header.e_machine == elf_header.EM_386
return result</p>
</dd>
<dt>def _have_compatible_manylinux_abi(arch):</dt><dd><p># type: (str) -&gt; bool
if arch == “armv7l”:</p>
<blockquote>
<div><p>return _is_linux_armhf()</p>
</div></blockquote>
<dl class="simple">
<dt>if arch == “i686”:</dt><dd><p>return _is_linux_i686()</p>
</dd>
</dl>
<p>return arch in {“x86_64”, “aarch64”, “ppc64”, “ppc64le”, “s390x”}</p>
</dd>
<dt>def _manylinux_tags(linux, arch):</dt><dd><p># type: (str, str) -&gt; Iterator[str]
# Oldest glibc to be supported regardless of architecture is (2, 17).
too_old_glibc2 = glibcVersion(2, 16)
if arch in {“x86_64”, “i686”}:</p>
<blockquote>
<div><p># On x86/i686 also oldest glibc to be supported is (2, 5).
too_old_glibc2 = glibcVersion(2, 4)</p>
</div></blockquote>
<p>current_glibc = glibcVersion(<a href="#id5"><span class="problematic" id="id6">*</span></a>_get_glibc_version())
glibc_max_list = [current_glibc]
# We can assume compatibility across glibc major versions.
# <a class="reference external" href="https://sourceware.org/bugzilla/show_bug.cgi?id=24636">https://sourceware.org/bugzilla/show_bug.cgi?id=24636</a>
#
# Build a list of maximum glibc versions so that we can
# output the canonical list of all glibc from current_glibc
# down to too_old_glibc2, including all intermediary versions.
for glibc_major in range(current_glibc.major - 1, 1, -1):</p>
<blockquote>
<div><p>glibc_max_list.append(glibcVersion(glibc_major, _LAST_GLIBC_MINOR[glibc_major]))</p>
</div></blockquote>
<dl>
<dt>for glibc_max in glibc_max_list:</dt><dd><dl>
<dt>if glibc_max.major == too_old_glibc2.major:</dt><dd><p>min_minor = too_old_glibc2.minor</p>
</dd>
<dt>else:</dt><dd><p># For other glibc major versions oldest supported is (x, 0).
min_minor = -1</p>
</dd>
<dt>for glibc_minor in range(glibc_max.minor, min_minor, -1):</dt><dd><p>glibc_version = (glibc_max.major, glibc_minor)
tag = “manylinux_{}_{}”.format(<a href="#id7"><span class="problematic" id="id8">*</span></a>glibc_version)
if _is_manylinux_compatible(tag, arch, glibc_version):</p>
<blockquote>
<div><p>yield linux.replace(“linux”, tag)</p>
</div></blockquote>
<p># Handle the legacy manylinux1, manylinux2010, manylinux2014 tags.
if glibc_version in _LEGACY_MANYLINUX_MAP:</p>
<blockquote>
<div><p>legacy_tag = _LEGACY_MANYLINUX_MAP[glibc_version]
if _is_manylinux_compatible(legacy_tag, arch, glibc_version):</p>
<blockquote>
<div><p>yield linux.replace(“linux”, legacy_tag)</p>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>def _linux_platforms(is_32bit=_32_BIT_INTERPRETER):</dt><dd><p># type: (bool) -&gt; Iterator[str]
linux = _normalize_string(distutils.util.get_platform())
if is_32bit:</p>
<blockquote>
<div><dl class="simple">
<dt>if linux == “linux_x86_64”:</dt><dd><p>linux = “linux_i686”</p>
</dd>
<dt>elif linux == “linux_aarch64”:</dt><dd><p>linux = “linux_armv7l”</p>
</dd>
</dl>
</div></blockquote>
<p>_, arch = linux.split(“_”, 1)
if _have_compatible_manylinux_abi(arch):</p>
<blockquote>
<div><dl class="simple">
<dt>for tag in _manylinux_tags(linux, arch):</dt><dd><p>yield tag</p>
</dd>
</dl>
</div></blockquote>
<p>yield linux</p>
</dd>
<dt>def _generic_platforms():</dt><dd><p># type: () -&gt; Iterator[str]
yield _normalize_string(distutils.util.get_platform())</p>
</dd>
<dt>def _platform_tags():</dt><dd><p># type: () -&gt; Iterator[str]
“””
Provides the platform tags for this installation.
“””
if platform.system() == “Darwin”:</p>
<blockquote>
<div><p>return mac_platforms()</p>
</div></blockquote>
<dl class="simple">
<dt>elif platform.system() == “Linux”:</dt><dd><p>return _linux_platforms()</p>
</dd>
<dt>else:</dt><dd><p>return _generic_platforms()</p>
</dd>
</dl>
</dd>
<dt>def interpreter_name():</dt><dd><p># type: () -&gt; str
“””
Returns the name of the running interpreter.
“””
try:</p>
<blockquote>
<div><p>name = sys.implementation.name  # type: ignore</p>
</div></blockquote>
<dl class="simple">
<dt>except AttributeError:  # pragma: no cover</dt><dd><p># Python 2.7 compatibility.
name = platform.python_implementation().lower()</p>
</dd>
</dl>
<p>return INTERPRETER_SHORT_NAMES.get(name) or name</p>
</dd>
<dt>def interpreter_version(<a href="#id9"><span class="problematic" id="id10">**</span></a>kwargs):</dt><dd><p># type: (bool) -&gt; str
“””
Returns the version of the running interpreter.
“””
warn = _warn_keyword_parameter(“interpreter_version”, kwargs)
version = _get_config_var(“py_version_nodot”, warn=warn)
if version:</p>
<blockquote>
<div><p>version = str(version)</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>version = _version_nodot(sys.version_info[:2])</p>
</dd>
</dl>
<p>return version</p>
</dd>
<dt>def _version_nodot(version):</dt><dd><p># type: (PythonVersion) -&gt; str
return “”.join(map(str, version))</p>
</dd>
<dt>def sys_tags(<a href="#id11"><span class="problematic" id="id12">**</span></a>kwargs):</dt><dd><p># type: (bool) -&gt; Iterator[Tag]
“””
Returns the sequence of tag triples for the running interpreter.</p>
<p>The order of the sequence corresponds to priority order for the
interpreter, from most to least important.
“””
warn = _warn_keyword_parameter(“sys_tags”, kwargs)</p>
<p>interp_name = interpreter_name()
if interp_name == “cp”:</p>
<blockquote>
<div><dl class="simple">
<dt>for tag in cpython_tags(warn=warn):</dt><dd><p>yield tag</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><dl class="simple">
<dt>for tag in generic_tags():</dt><dd><p>yield tag</p>
</dd>
</dl>
</dd>
<dt>for tag in compatible_tags():</dt><dd><p>yield tag</p>
</dd>
</dl>
</dd>
</dl>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, hrishabh kamal.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>